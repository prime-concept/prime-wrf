# WRF

<details>
<summary>Частично устаревшая версия</summary>

## Макеты
Фигма с макетами – https://www.figma.com/file/CV2dMCzMQA4NV0R1CjgT4HOC/WRF-Club-%2F-iOS-App?node-id=434%3A13753

## API
В проекте используется 2 бекенда, которые взаимодействуют между собой:
1. PrimePass CRM – https://crm-dev.primepass.ru/docs/ – операции, связанные с данными клиентов (регистрация, авторизация, лояльность и персональные данные)
2. Navigator – https://wrf.technolab.com.ru/v1/ – контент (рестораны, события)

## WGKit
В качестве зависимости подтягивается либа `WGKit`, которая содержит общий код, который мы шарим между разными проектами внутри WG.

## SwiftLint

В run phase добавлен запуск линтера. Рекомендуется держать нулевое количество предупреждений.  
Также в корне проекта есть скрипт `analyze_swiftlint.sh`, который собирает проект и запускает swiftlint в режиме analyze. Это сделано в виде отдельной процедуры так как вся операция может занимать достаточно много времени.   
Перед мерджем веток в develop / master необходимо убедиться, что запуск `analyze_swiftlint.sh` не возвращает ошибок. 

## Верстка

В проекте не используются xib'ы, storyboard'ы и всё, что связано с IB. Дополнительно данные вещи запрещены правилом `prohibited_interface_builder` линтера.  
В качестве DSL используется *SnapKit*. Для сохранения консистентности верстки существует протокол `ProgrammaticallyDesignable`, методы которого нужно вызывать в инициализаторе кастомной вьюшки.   
Для описания констант, используемых в верстке, применяется подход с объявлением структуры `Appearance`, которая передается в инициализатор класса. Тем самым возможно переиспользование вьюшек или использование их в нескольких конфигурациях.   
В качестве альтернативы (например, когда отдельная структура не нужна) для хранения констант используется enum `Appearance`.

## Архитектура
В проекте используется Model-View-Presenter. Каждый модуль состоит из следующих частей:
* Assembly – используется как точка входа конечного модуля: для передачи параметров в/из модуля и для сборки готового модуля;
* ViewController – стандартный view controller, содержит логику представления. Метод `loadView()` инициализирует отдельную View;
* View – содержит UI компоненты и описание layout'а
* Presenter – содержит бизнес-логику. Отдельные, переиспользуемые части должны быть вынесены в сервисы  


ViewController и Presenter реализуют соответствующие протоколы, через которые осуществляется взаимодействие между ними.   

В проекте есть шаблон для [Generamba](https://github.com/strongself/Generamba), с помощью которого можно сгенерировать чистый модуль:  
```
generamba gen <имя_модуля> wrf-module
```

## Floating controller 

В интерфейсе приложения используются контроллеры, которые выезжают снизу экрана и могу находиться в трёх различных состояниях. Логика взаимодействия с такими контроллерами инкапсулирована в классе `FloatingControllerPresentationManager`.  
Каждый представленный floating controller может находиться в двух состояниях:
* Развернут на половину – промежуточное состояние, часть экрана не занята
* Развернут полностью – контроллер развернут до края статус бара

Описание каждого кейса находится в енуме `FloatingControllerContext` – отступ от верхнего края в промежуточном состоянии, разрешено ли разворачивать на весь экран, начальная позиция.  
Для представления произвольного UIViewController в виде плавающего контроллера нужно инициализировать `FloatingControllerPresentationManager` со следующими параметрами:
* `context` – описание представления
* `groupID` – идентификатор отдельной группы floating контроллеров. Необходим, чтобы обеспечить связать между собой несколько разных контроллеров (см. `shouldMinimizePreviousController` далее)
* `contentViewController` – контроллер, который представляем
* `sourceViewController` – родительский контроллер
* `shouldMinimizePreviousController` – если true, то в момент вызова `present()` последний из представленных контроллеров с текущим `groupID` будет свернут до такого состояния, что его верхний отступ будет больше отступа нового контроллера на константу `FloatingControllerPresentationManager.Appearance.minimizationOffset`. Пример такого поведения – контроллер бронирования поверх контроллера с описанием ресторана 
* `grabberAppearance` – внешний вид grabber индикатора

</details>
